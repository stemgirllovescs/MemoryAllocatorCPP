        -:    0:Source:Allocator.hpp
        -:    0:Graph:test_Allocator.gcno
        -:    0:Data:test_Allocator.gcda
        -:    0:Runs:1
        -:    1:// -------------
        -:    2: // Allocator.hpp
        -:    3: // -------------
        -:    4:
        -:    5:#ifndef Allocator_hpp
        -:    6:#define Allocator_hpp
        -:    7:
        -:    8:// --------
        -:    9:// includes
        -:   10:// --------
        -:   11:
        -:   12:#include <cassert>   // assert
        -:   13:#include <cstddef>   // ptrdiff_t, size_t
        -:   14:#include <new>       // bad_alloc, new
        -:   15:#include <stdexcept> // invalid_argument
        -:   16:
        -:   17:// ------------
        -:   18:// My_Allocator
        -:   19:// ------------
        -:   20:
        -:   21:template <typename T, std::size_t N>
        -:   22:class My_Allocator {
        -:   23:    // -----------
        -:   24:    // operator ==
        -:   25:    // -----------
        -:   26:
        -:   27:    friend bool operator == (const My_Allocator&, const My_Allocator&) { // this is correct
        -:   28:        return false;}
        -:   29:
        -:   30:    // -----------
        -:   31:    // operator !=
        -:   32:    // -----------
        -:   33:
        -:   34:    friend bool operator != (const My_Allocator& lhs, const My_Allocator& rhs) { // this is correct
        -:   35:        return !(lhs == rhs);}
        -:   36:
        -:   37:    public:
        -:   38:        // --------
        -:   39:        // typedefs
        -:   40:        // --------
        -:   41:
        -:   42:        using value_type      = T;
        -:   43:
        -:   44:        using size_type       = std::size_t;
        -:   45:        using difference_type = std::ptrdiff_t;
        -:   46:
        -:   47:        using pointer         =       value_type*;
        -:   48:        using const_pointer   = const value_type*;
        -:   49:
        -:   50:        using reference       =       value_type&;
        -:   51:        using const_reference = const value_type&;
        -:   52:
        -:   53:    public:
        -:   54:        // ---------------
        -:   55:        // iterator
        -:   56:        // over the blocks
        -:   57:        // ---------------
        -:   58:
        -:   59:        class iterator {
        -:   60:            // -----------
        -:   61:            // operator ==
        -:   62:            // -----------
        -:   63:
       31:   64:            friend bool operator == (const iterator& lhs, const iterator& rhs) { // fix!
      31*:   65:                return (&lhs._r == &rhs._r) && (lhs._i == rhs._i); }
        -:   66:
        -:   67:            // -----------
        -:   68:            // operator !=
        -:   69:            // -----------
        -:   70:
       31:   71:            friend bool operator != (const iterator& lhs, const iterator& rhs) { // this is correct
       31:   72:                return !(lhs == rhs);}
        -:   73:
        -:   74:            public:
        -:   75:                // ----
        -:   76:                // data
        -:   77:                // ----
        -:   78:
        -:   79:                My_Allocator& _r;
        -:   80:                std::size_t   _i;
        -:   81:
        -:   82:            public:
        -:   83:                // -----------
        -:   84:                // constructor
        -:   85:                // -----------
        -:   86:
       52:   87:                iterator (My_Allocator& r, size_type i) :
       52:   88:                        _r (r),
       52:   89:                        _i (i)
       52:   90:                    {}
        -:   91:
        -:   92:                // ----------
        -:   93:                // operator *
        -:   94:                // ----------
        -:   95:
       31:   96:                int& operator * () const { // fix!
       31:   97:                    return _r[_i];}
        -:   98:
        -:   99:                // -----------
        -:  100:                // operator ++
        -:  101:                // -----------
        -:  102:
       10:  103:                iterator& operator ++ () { // fix!
       10:  104:                    int block_size = std::abs(_r[_i]);
       10:  105:                    _i += block_size + 8;
       10:  106:                    return *this;}
        -:  107:
        -:  108:                // -----------
        -:  109:                // operator ++
        -:  110:                // -----------
        -:  111:
        -:  112:                iterator operator ++ (int) { // this is correct
        -:  113:                    iterator x = *this;
        -:  114:                    ++*this;
        -:  115:                    return x;}
        -:  116:
        -:  117:                // -----------
        -:  118:                // operator --
        -:  119:                // -----------
        -:  120:
        -:  121:                iterator& operator -- () { // fix!
        -:  122:                    int prevEndIndex = _i - 4;
        -:  123:                    int prevSize = std::abs(_r[prevEndIndex]);
        -:  124:                    _i -= prevSize + 8;
        -:  125:                    return *this;}
        -:  126:
        -:  127:                // -----------
        -:  128:                // operator --
        -:  129:                // -----------
        -:  130:
        -:  131:                iterator operator -- (int) { // this is correct
        -:  132:                    iterator x = *this;
        -:  133:                    --*this;
        -:  134:                    return x;}};
        -:  135:
        -:  136:        // ---------------
        -:  137:        // const_iterator
        -:  138:        // over the blocks
        -:  139:        // ---------------
        -:  140:
        -:  141:        class const_iterator {
        -:  142:            // -----------
        -:  143:            // operator ==
        -:  144:            // -----------
        -:  145:
        -:  146:            friend bool operator == (const const_iterator& lhs, const const_iterator& rhs) { // fix!
        -:  147:                return (&lhs._r == &rhs._r) && (lhs._i == rhs._i); }
        -:  148:
        -:  149:            // -----------
        -:  150:            // operator !=
        -:  151:            // -----------
        -:  152:
        -:  153:            friend bool operator != (const const_iterator& lhs, const const_iterator& rhs) { // this is correct
        -:  154:                return !(lhs == rhs);}
        -:  155:
        -:  156:            public:
        -:  157:                // ----
        -:  158:                // data
        -:  159:                // ----
        -:  160:
        -:  161:                const My_Allocator& _r;
        -:  162:                std::size_t         _i;
        -:  163:
        -:  164:            public:
        -:  165:                // -----------
        -:  166:                // constructor
        -:  167:                // -----------
        -:  168:
        -:  169:                const_iterator (const My_Allocator& r, size_type i) :
        -:  170:                        _r (r),
        -:  171:                        _i (i)
        -:  172:                    {}
        -:  173:
        -:  174:                // ----------
        -:  175:                // operator *
        -:  176:                // ----------
        -:  177:
        -:  178:                // beginning sentinel of the block
        -:  179:                const int& operator * () const { // fix!
        -:  180:                    return _r[_i];}
        -:  181:
        -:  182:                // -----------
        -:  183:                // operator ++
        -:  184:                // -----------
        -:  185:
        -:  186:                const_iterator& operator ++ () { // fix!
        -:  187:                    int block_size = std::abs(_r[_i]);
        -:  188:                    _i += block_size + 8;
        -:  189:                    return *this;}
        -:  190:
        -:  191:                // -----------
        -:  192:                // operator ++
        -:  193:                // -----------
        -:  194:
        -:  195:                const_iterator operator ++ (int) { // this is correct
        -:  196:                    const_iterator tmp = *this;
        -:  197:                    ++*this;
        -:  198:                    return tmp;}
        -:  199:
        -:  200:                // -----------
        -:  201:                // operator --
        -:  202:                // -----------
        -:  203:
        -:  204:                const_iterator& operator -- () { // fix!
        -:  205:                    int prevEndIndex = _i - 4;
        -:  206:                    int prevSize = std::abs(_r[prevEndIndex]);
        -:  207:                    _i -= prevSize + 8;
        -:  208:                    return *this;}
        -:  209:
        -:  210:                // -----------
        -:  211:                // operator --
        -:  212:                // -----------
        -:  213:
        -:  214:                const_iterator operator -- (int) { // this is correct
        -:  215:                    const_iterator tmp = *this;
        -:  216:                    --*this;
        -:  217:                    return tmp;}};
        -:  218:
        -:  219:    private:
        -:  220:        // ----
        -:  221:        // data
        -:  222:        // ----
        -:  223:
        -:  224:        char a[N]; // array of bytes
        -:  225:
        -:  226:        // -----
        -:  227:        // valid
        -:  228:        // -----
        -:  229:
        -:  230:        /**
        -:  231:         * O(1) in space
        -:  232:         * O(n) in time
        -:  233:         * Check if the allocator's sentinels are consistent
        -:  234:         */
       64:  235:        bool valid () const {
       64:  236:            int i = 0;
      190:  237:            while (i < static_cast<int>(N)){
      126:  238:                int block_size = (*this)[i];
      126:  239:                int block_end = i + 4 + std::abs(block_size);
      126:  240:                if (block_end + 4 > static_cast<int>(N)){
    #####:  241:                    return false;
        -:  242:                }
      126:  243:                int end_sentinel = (*this)[block_end];
      126:  244:                if (block_size != end_sentinel){
    #####:  245:                    return false;
        -:  246:                }
      126:  247:                i = block_end + 4;
        -:  248:            }
       64:  249:            return true;
        -:  250:        }
        -:  251:
        -:  252:    public:
        -:  253:        // -----------
        -:  254:        // constructor
        -:  255:        // -----------
        -:  256:
        -:  257:        /**
        -:  258:         * O(1) in space
        -:  259:         * O(1) in time
        -:  260:         * throw a std::bad_alloc exception, if N is less than sizeof(T) + (2 * sizeof(int))
        -:  261:         */
       10:  262:        My_Allocator () {
        -:  263:            if (N < (8 + (2 * sizeof(int))))
        -:  264:                throw std::bad_alloc();
       10:  265:            (*this)[0]   = N-8;
       10:  266:            (*this)[N-4] = N-8;
      10*:  267:            assert(valid());}
        -:  268:
        -:  269:        My_Allocator             (const My_Allocator&) = default;
        -:  270:        ~My_Allocator            ()                    = default;
        -:  271:        My_Allocator& operator = (const My_Allocator&) = default;
        -:  272:
        -:  273:        // --------
        -:  274:        // allocate
        -:  275:        // --------
        -:  276:
        -:  277:        /**
        -:  278:         * O(1) in space
        -:  279:         * O(n) in time
        -:  280:         * after allocation there must be enough space left for a valid block
        -:  281:         * the smallest allowable block is sizeof(T) + (2 * sizeof(int))
        -:  282:         * choose the first block that fits
        -:  283:         * throw a std::bad_alloc exception, if there isn't an acceptable free block
        -:  284:         */
       21:  285:pointer allocate (size_type s) {
       21:  286:    int size_in_bytes = s * 8; // Object size is 8 bytes
        -:  287:
       31:  288:    for (iterator it = begin(); it != end(); ++it) {
       31:  289:        int& block_size = *it;
       31:  290:        if (block_size > 0 && block_size >= size_in_bytes) {
       21:  291:            int original_size = block_size;
       21:  292:            int remaining = original_size - size_in_bytes - 8; // Remaining data size after allocating and adding end sentinel
        -:  293:
       21:  294:            if (remaining >= static_cast<int>(8)){
        -:  295:                // Split the block
       20:  296:                block_size = -size_in_bytes;
       20:  297:                (*this)[it._i + 4 + size_in_bytes] = -size_in_bytes; // End sentinel for allocated block
        -:  298:                // Create new free block
       20:  299:                int new_block_index = it._i + 8 + size_in_bytes;
       20:  300:                (*this)[new_block_index] = remaining;
       20:  301:                (*this)[new_block_index + 4 + remaining] = remaining;
        -:  302:            } else {
        -:  303:                // Do not split, allocate entire block
        1:  304:                block_size = -original_size;
        1:  305:                (*this)[it._i + 4 + original_size] = -original_size;
        -:  306:            }
      21*:  307:            assert(valid());
       21:  308:            return reinterpret_cast<pointer>(&a[it._i +4]);
        -:  309:        }
        -:  310:    }
    #####:  311:    throw std::bad_alloc();
        -:  312:}
        -:  313:
        -:  314:
        -:  315:        // ---------
        -:  316:        // construct
        -:  317:        // ---------
        -:  318:
        -:  319:        /**
        -:  320:         * O(1) in space
        -:  321:         * O(1) in time
        -:  322:         */
        6:  323:        void construct (pointer p, const_reference v) { // this is correct and exempt
        6:  324:            new (p) T(v);                               // from the prohibition of new
       6*:  325:            assert(valid());}
        -:  326:        // ----------
        -:  327:        // deallocate
        -:  328:        // ----------
        -:  329:
        -:  330:        /**
        -:  331:         * O(1) in space
        -:  332:         * O(1) in time
        -:  333:         * after deallocation adjacent free blocks must be coalesced
        -:  334:         * throw an invalid_argument exception, if p is invalid
        -:  335:         */
        -:  336:        // ----------
        -:  337:// deallocate
        -:  338:// ----------
        -:  339:
        -:  340:/**
        -:  341: * O(1) in space
        -:  342: * O(1) in time
        -:  343: * after deallocation adjacent free blocks must be coalesced
        -:  344: * throw an invalid_argument exception, if p is invalid
        -:  345: */
        -:  346:// deallocate
        -:  347:// ----------
        -:  348:
        -:  349:/**
        -:  350: * O(1) in space
        -:  351: * O(1) in time
        -:  352: * After deallocation adjacent free blocks must be coalesced.
        -:  353: * Throw an invalid_argument exception, if p is invalid.
        -:  354: */
       21:  355:void deallocate(pointer p, size_type) {
       21:  356:    int index = reinterpret_cast<char*>(p) - a - 4;
       21:  357:    if (index < 0 || index >= static_cast<int>(N)) {
    #####:  358:        throw std::invalid_argument("Invalid pointer");
        -:  359:    }
        -:  360:
       21:  361:    int& block_size = (*this)[index];
       21:  362:    if (block_size >= 0) {
    #####:  363:        throw std::invalid_argument("Block is already free");
        -:  364:    }
        -:  365:
        -:  366:    // Mark block as free
       21:  367:    int size = -block_size;
       21:  368:    block_size = size;
       21:  369:    (*this)[index + 4 + size] = size;
        -:  370:
        -:  371:    // Coalesce with the next block if it is free
       21:  372:    int next_index = index + size + 8;
       21:  373:    if (next_index < static_cast<int>(N)) {
       21:  374:        int& next_block_size = (*this)[next_index];
       21:  375:        if (next_block_size > 0) {
        -:  376:            // Update size to include the next free block and the header/footer
       14:  377:            size += next_block_size + 8;
       14:  378:            (*this)[index] = size;  // Update start sentinel
       14:  379:            (*this)[index + 4 + size] = size;  // Update end sentinel
       14:  380:            block_size = size; // Update block_size after coalescing
        -:  381:        }
        -:  382:    }
        -:  383:
        -:  384:    // Coalesce with the previous block if it is free
       21:  385:    if (index > 0) {
       10:  386:        int prev_end_index = index - 4;
       10:  387:        int prev_size = (*this)[prev_end_index];
       10:  388:        if (prev_size > 0) {
        6:  389:            int prev_index = index - prev_size - 8;
        -:  390:            // Update size to include the previous free block and the header/footer
        6:  391:            size += prev_size + 8;
        6:  392:            (*this)[prev_index] = size;  // Update start sentinel
        6:  393:            (*this)[prev_index + 4 + size] = size;  // Update end sentinel
        6:  394:            index = prev_index;      // Update index to new start
        6:  395:            block_size = size;       // Update block_size to new size
        -:  396:        }
        -:  397:    }
        -:  398:
      21*:  399:    assert(valid());
       21:  400:}
        -:  401:
        -:  402:
        -:  403:
        -:  404:        // -------
        -:  405:        // destroy
        -:  406:        // -------
        -:  407:
        -:  408:        /**
        -:  409:         * O(1) in space
        -:  410:         * O(1) in time
        -:  411:         */
        6:  412:        void destroy (pointer p) { // this is correct
        6:  413:            p->~T();
       6*:  414:            assert(valid());}
        -:  415:
        -:  416:        // -----------
        -:  417:        // operator []
        -:  418:        // -----------
        -:  419:
        -:  420:        /**
        -:  421:         * O(1) in space
        -:  422:         * O(1) in time
        -:  423:         */
      237:  424:        int& operator [] (int i) { // this is correct
      237:  425:            return *reinterpret_cast<int*>(&a[i]);}
        -:  426:
        -:  427:        /**
        -:  428:         * O(1) in space
        -:  429:         * O(1) in time
        -:  430:         */
      254:  431:        const int& operator [] (int i) const { // this is correct
      254:  432:            return *reinterpret_cast<const int*>(&a[i]);}
        -:  433:
        -:  434:        // -----
        -:  435:        // begin
        -:  436:        // -----
        -:  437:
       21:  438:        iterator begin () { // this is correct
       21:  439:            return iterator(*this, 0);}
        -:  440:
        -:  441:        const_iterator begin () const { // this is correct
        -:  442:            return const_iterator(*this, 0);}
        -:  443:
        -:  444:        // ---
        -:  445:        // end
        -:  446:        // ---
        -:  447:
       31:  448:        iterator end () { // this is correct
       31:  449:            return iterator(*this, N);}
        -:  450:
        -:  451:        const_iterator end () const { // this is correct
        -:  452:            return const_iterator(*this, N);}};
        -:  453:
        -:  454:
        -:  455:
        -:  456:#endif // Allocator_hpp
